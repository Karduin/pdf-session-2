    \hypertarget{muxe9thodes-spuxe9cifiques-aux-listes}{%
\section{Méthodes spécifiques aux
listes}\label{muxe9thodes-spuxe9cifiques-aux-listes}}

    \hypertarget{compluxe9ment---niveau-basique}{%
\subsection{Complément - niveau
basique}\label{compluxe9ment---niveau-basique}}

    Voici quelques unes des méthodes disponibles sur le type \texttt{list}.

    \hypertarget{trouver-linformation}{%
\subsubsection{Trouver l'information}\label{trouver-linformation}}

    Pour commencer, rappelons comment retrouver la liste des méthodes
définies sur le type \texttt{list}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{n}{help}\PY{p}{(}\PY{n+nb}{list}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Help on class list in module builtins:

class list(object)
 |  list() -> new empty list
 |  list(iterable) -> new list initialized from iterable's items
 |  
 |  Methods defined here:
 |  
 |  \_\_add\_\_(self, value, /)
 |      Return self+value.
 |  
 |  \_\_contains\_\_(self, key, /)
 |      Return key in self.
 |  
 |  \_\_delitem\_\_(self, key, /)
 |      Delete self[key].
 |  
 |  \_\_eq\_\_(self, value, /)
 |      Return self==value.
 |  
 |  \_\_ge\_\_(self, value, /)
 |      Return self>=value.
 |  
 |  \_\_getattribute\_\_(self, name, /)
 |      Return getattr(self, name).
 |  
 |  \_\_getitem\_\_({\ldots})
 |      x.\_\_getitem\_\_(y) <==> x[y]
 |  
 |  \_\_gt\_\_(self, value, /)
 |      Return self>value.
 |  
 |  \_\_iadd\_\_(self, value, /)
 |      Implement self+=value.
 |  
 |  \_\_imul\_\_(self, value, /)
 |      Implement self*=value.
 |  
 |  \_\_init\_\_(self, /, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  \_\_iter\_\_(self, /)
 |      Implement iter(self).
 |  
 |  \_\_le\_\_(self, value, /)
 |      Return self<=value.
 |  
 |  \_\_len\_\_(self, /)
 |      Return len(self).
 |  
 |  \_\_lt\_\_(self, value, /)
 |      Return self<value.
 |  
 |  \_\_mul\_\_(self, value, /)
 |      Return self*value.n
 |  
 |  \_\_ne\_\_(self, value, /)
 |      Return self!=value.
 |  
 |  \_\_new\_\_(*args, **kwargs) from builtins.type
 |      Create and return a new object.  See help(type) for accurate signature.
 |  
 |  \_\_repr\_\_(self, /)
 |      Return repr(self).
 |  
 |  \_\_reversed\_\_({\ldots})
 |      L.\_\_reversed\_\_() -- return a reverse iterator over the list
 |  
 |  \_\_rmul\_\_(self, value, /)
 |      Return self*value.
 |  
 |  \_\_setitem\_\_(self, key, value, /)
 |      Set self[key] to value.
 |  
 |  \_\_sizeof\_\_({\ldots})
 |      L.\_\_sizeof\_\_() -- size of L in memory, in bytes
 |  
 |  append({\ldots})
 |      L.append(object) -> None -- append object to end
 |  
 |  clear({\ldots})
 |      L.clear() -> None -- remove all items from L
 |  
 |  copy({\ldots})
 |      L.copy() -> list -- a shallow copy of L
 |  
 |  count({\ldots})
 |      L.count(value) -> integer -- return number of occurrences of value
 |  
 |  extend({\ldots})
 |      L.extend(iterable) -> None -- extend list by appending elements from the iterable
 |  
 |  index({\ldots})
 |      L.index(value, [start, [stop]]) -> integer -- return first index of value.
 |      Raises ValueError if the value is not present.
 |  
 |  insert({\ldots})
 |      L.insert(index, object) -- insert object before index
 |  
 |  pop({\ldots})
 |      L.pop([index]) -> item -- remove and return item at index (default last).
 |      Raises IndexError if list is empty or index is out of range.
 |  
 |  remove({\ldots})
 |      L.remove(value) -> None -- remove first occurrence of value.
 |      Raises ValueError if the value is not present.
 |  
 |  reverse({\ldots})
 |      L.reverse() -- reverse *IN PLACE*
 |  
 |  sort({\ldots})
 |      L.sort(key=None, reverse=False) -> None -- stable sort *IN PLACE*
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  \_\_hash\_\_ = None


    \end{Verbatim}

    Ignorez les méthodes dont le nom commence et termine par \texttt{\_\_}
(nous parlerons de ceci en semaine 6), vous trouvez alors les méthodes
utiles listées entre \texttt{append} et \texttt{sort}.\\

Certaines de ces méthodes ont été vues dans la vidéo sur les séquences,
c'est le cas notamment de \texttt{count} et \texttt{index}.\\

    Nous allons à présent décrire les autres, partiellement et brièvement.
Un autre complément décrit la méthode \texttt{sort}. Reportez-vous au
lien donné en fin de notebook pour obtenir une information plus
complète.\\

    Donnons-nous pour commencer une liste témoin~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n}{liste} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, 2, 3]

    \end{Verbatim}

    \textbf{Avertissements}~:

\begin{itemize}
\tightlist
\item
  soyez bien attentifs au nombre de fois où vous exécutez les cellules
  de ce notebook~;
\item
  par exemple une liste renversée deux fois peut donner l'impression que
  \texttt{reverse} ne marche pas~;
\item
  n'hésitez pas à utiliser le menu \emph{Cell~-\textgreater{}~Run~All}
  pour réexécuter en une seule fois le notebook entier.
\end{itemize}

    \hypertarget{append}{%
\subsubsection{\texorpdfstring{\textbf{append}}{append}}\label{append}}

    La méthode \texttt{append} permet d'ajouter \textbf{un élément} à la fin
d'une liste~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{liste}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ap}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, 2, 3, 'ap']

    \end{Verbatim}

    \hypertarget{extend}{%
\subsubsection{\texorpdfstring{\textbf{extend}}{extend}}\label{extend}}

    La méthode \texttt{extend} réalise la même opération, mais avec
\textbf{tous les éléments} de la liste qu'on lui passe en argument~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{n}{liste2} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ex1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ex2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
        \PY{n}{liste}\PY{o}{.}\PY{n}{extend}\PY{p}{(}\PY{n}{liste2}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, 2, 3, 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    \hypertarget{append-vs}{%
\subsubsection{\texorpdfstring{\textbf{append} \emph{vs}
\textbf{+}}{append vs +}}\label{append-vs}}

    Ces deux méthodes \texttt{append} et \texttt{extend} sont donc assez
voisines~; avant de voir d'autres méthodes de \texttt{list}, prenons un
peu le temps de comparer leur comportement avec l'addition \texttt{+} de
liste. L'élément clé ici, on l'a déjà vu dans la vidéo, est que la liste
est un objet \textbf{mutable}. \texttt{append} et \texttt{extend}
\textbf{modifient} la liste sur laquelle elles travaillent, alors que
l'addition \textbf{crée un nouvel objet}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{c+c1}{\PYZsh{} pour créer une liste avec les n premiers entiers, on utilise}
        \PY{c+c1}{\PYZsh{} la fonction built\PYZhy{}in range(), que l\PYZsq{}on convertit en liste}
        \PY{c+c1}{\PYZsh{} on aura l\PYZsq{}occasion d\PYZsq{}y revenir}
        \PY{n}{a1} \PY{o}{=} \PY{n+nb}{list}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{a1}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[0, 1, 2]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n}{a2} \PY{o}{=} \PY{n+nb}{list}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{13}\PY{p}{)}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{a2}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[10, 11, 12]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{c+c1}{\PYZsh{} le fait d\PYZsq{}utiliser + crée une nouvelle liste}
        \PY{n}{a3} \PY{o}{=} \PY{n}{a1} \PY{o}{+} \PY{n}{a2}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{c+c1}{\PYZsh{} si bien que maintenant on a trois objets différents}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{a1}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{a2}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a3}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{a3}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
a1 [0, 1, 2]
a2 [10, 11, 12]
a3 [0, 1, 2, 10, 11, 12]

    \end{Verbatim}

    Comme on le voit, après une addition, les deux termes de l'addition sont
inchangés. Pour bien comprendre, voyons exactement le même scénario sous
pythontutor~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{o}{\PYZpc{}}\PY{k}{load\PYZus{}ext} ipythontutor
\end{Verbatim}


    \textbf{Note}~: une fois que vous avez évalué la cellule avec
\texttt{\%\%ipythontutor}, vous devez cliquer sur le bouton
\texttt{Forward} pour voir pas à pas le comportement du programme.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{ipythontutor} height=230 ratio=0.7
        a1 = list(range(3))
        a2 = list(range(10, 13))
        a3 = a1 + a2
\end{Verbatim}


    Alors que si on avait utilisé \texttt{extend}, on aurait obtenu ceci~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{ipythontutor} height=200 ratio=0.75
        e1 = list(range(3))
        e2 = list(range(10, 13))
        e3 = e1.extend(e2)
\end{Verbatim}


    Ici on tire profit du fait que la liste est un objet mutable~:
\texttt{extend} \textbf{modifie} l'objet sur lequel on l'appelle (ici
\texttt{e1}). Dans ce scénario on ne crée en tout que deux objets, et du
coup il est inutile pour extend de renvoyer quoi que ce soit, et c'est
pourquoi \texttt{e3} ici vaut None.\\

    C'est pour cette raison que~:

\begin{itemize}
\tightlist
\item
  l'addition est disponible sur tous les types séquences - on peut
  toujours réaliser l'addition puisqu'on crée un nouvel objet pour
  stocker le résultat de l'addition~;
\item
  mais \texttt{append} et \texttt{extend} ne sont par exemple
  \textbf{pas disponibles} sur les chaînes de caractères, qui sont
  \textbf{immuables} - si \texttt{e1} était une chaîne, on ne pourrait
  pas la modifier pour lui ajouter des éléments.
\end{itemize}

    \hypertarget{insert}{%
\subsubsection{\texorpdfstring{\textbf{insert}}{insert}}\label{insert}}

    Reprenons notre inventaire des méthodes de \texttt{list}, et pour cela
rappelons nous le contenu de la variable \texttt{liste}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{n}{liste}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}9}]:} [0, 1, 2, 3, 'ap', 'ex1', 'ex2']
\end{Verbatim}
            
    La méthode \texttt{insert} permet, comme le nom le suggère, d'insérer un
élément à une certaine position~; comme toujours les indices commencent
à zéro et donc~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{c+c1}{\PYZsh{} insérer à l\PYZsq{}index 2}
         \PY{n}{liste}\PY{o}{.}\PY{n}{insert}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{1 bis}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, '1 bis', 2, 3, 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    On peut remarquer qu'un résultat analogue peut être obtenu avec une
affectation de slice~; par exemple pour insérer au rang 5 (i.e.~avant
\texttt{ap}), on pourrait aussi bien faire~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{liste}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{:}\PY{l+m+mi}{5}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{3 bis}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, '1 bis', 2, 3, '3 bis', 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    \hypertarget{remove}{%
\subsubsection{\texorpdfstring{\textbf{remove}}{remove}}\label{remove}}

    La méthode \texttt{remove} détruit la \textbf{première occurrence} d'un
objet dans la liste~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{n}{liste}\PY{o}{.}\PY{n}{remove}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, '1 bis', 2, '3 bis', 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    \hypertarget{pop}{%
\subsubsection{\texorpdfstring{\textbf{pop}}{pop}}\label{pop}}

    La méthode \texttt{pop} prend en argument un indice~; elle permet
d'extraire l'élément à cet indice. En un seul appel on obtient la valeur
de l'élément et on l'enlève de la liste~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{n}{popped} \PY{o}{=} \PY{n}{liste}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{popped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{popped}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
popped 0 liste [1, '1 bis', 2, '3 bis', 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    Si l'indice n'est pas précisé, c'est le dernier élément de la liste qui
est visé~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n}{popped} \PY{o}{=} \PY{n}{liste}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{popped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{popped}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
popped ex2 liste [1, '1 bis', 2, '3 bis', 'ap', 'ex1']

    \end{Verbatim}

    \hypertarget{reverse}{%
\subsubsection{\texorpdfstring{\textbf{reverse}}{reverse}}\label{reverse}}

    Enfin \texttt{reverse} renverse la liste, le premier élément devient le
dernier~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n}{liste}\PY{o}{.}\PY{n}{reverse}\PY{p}{(}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste ['ex1', 'ap', '3 bis', 2, '1 bis', 1]

    \end{Verbatim}

    On peut remarquer ici que le résultat se rapproche de ce qu'on peut
obtenir avec une opération de slicing comme ceci~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n}{liste2} \PY{o}{=} \PY{n}{liste}\PY{p}{[}\PY{p}{:}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste2}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste2 [1, '1 bis', 2, '3 bis', 'ap', 'ex1']

    \end{Verbatim}

    \textbf{À la différence toutefois} qu'avec le slicing c'est une copie de
la liste initiale qui est retournée, la liste de départ quant à elle
n'est pas modifiée.

    \hypertarget{pour-en-savoir-plus}{%
\subsubsection{Pour en savoir plus}\label{pour-en-savoir-plus}}

    \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}

    \hypertarget{note-spuxe9cifique-aux-notebooks}{%
\subsubsection{Note spécifique aux
notebooks}\label{note-spuxe9cifique-aux-notebooks}}

    \hypertarget{help-avec}{%
\paragraph{\texorpdfstring{\texttt{help} avec
\texttt{?}}{help avec ?}}\label{help-avec}}

    Je vous signale en passant que dans un notebook vous pouvez obtenir de
l'aide avec un point d'interrogation \texttt{?} inséré avant ou après un
symbole. Par exemple pour obtenir des précisions sur la méthode
\texttt{list.pop}, on peut faire soit~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{c+c1}{\PYZsh{} fonctionne dans tous les environnements Python}
         \PY{n}{help}\PY{p}{(}\PY{n+nb}{list}\PY{o}{.}\PY{n}{pop}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Help on method\_descriptor:

pop({\ldots})
    L.pop([index]) -> item -- remove and return item at index (default last).
    Raises IndexError if list is empty or index is out of range.


    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{c+c1}{\PYZsh{} spécifique aux notebooks}
         \PY{c+c1}{\PYZsh{} l\PYZsq{}affichage obtenu est légèrement différent}
         \PY{c+c1}{\PYZsh{} tapez la touche \PYZsq{}Esc\PYZsq{} \PYZhy{} ou cliquez la petite croix}
         \PY{c+c1}{\PYZsh{} pour faire disparaitre le dialogue qui apparaît en bas}
         list.pop\PY{o}{?}
\end{Verbatim}


    \hypertarget{compluxe9tion-avec-tab}{%
\paragraph{\texorpdfstring{Complétion avec
\texttt{Tab}}{Complétion avec Tab}\\\\}\label{compluxe9tion-avec-tab}}

    Dans un notebook vous avez aussi la complétion~; si vous tapez - dans
une cellule de code - le début d'un symbole connu dans l'environnement~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} placez votre curseur à la fin de la ligne après \PYZsq{}li\PYZsq{}}
        \PY{c+c1}{\PYZsh{} et appuyez sur la touche \PYZsq{}Tab\PYZsq{}}
        \PY{n}{li}
\end{Verbatim}


    Vous voyez apparaître un dialogue avec les noms connus qui commencent
par \texttt{li}~; utilisez les flèches pour choisir, et `Return' pour
sélectionner.