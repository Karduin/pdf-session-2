    \hypertarget{la-construction-de-tuples}{%
\section{La construction de tuples}\label{la-construction-de-tuples}}

    \hypertarget{compluxe9ment---niveau-intermuxe9diaire}{%
\subsection{Complément - niveau
intermédiaire}\label{compluxe9ment---niveau-intermuxe9diaire}}

    \hypertarget{les-tuples-et-la-virgule-terminale}{%
\subsubsection{Les tuples et la virgule
terminale}\label{les-tuples-et-la-virgule-terminale}}

    Comme on l'a vu dans la vidéo, on peut construire un tuple à deux
éléments - un couple - de quatre façons~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{c+c1}{\PYZsh{} sans parenthèse ni virgule terminale}
        \PY{n}{couple1} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}
        \PY{c+c1}{\PYZsh{} avec parenthèses}
        \PY{n}{couple2} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
        \PY{c+c1}{\PYZsh{} avec virgule terminale}
        \PY{n}{couple3} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,}
        \PY{c+c1}{\PYZsh{} avec parenthèses et virgule}
        \PY{n}{couple4} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{c+c1}{\PYZsh{} toutes ces formes sont équivalentes ; par exemple}
        \PY{n}{couple1} \PY{o}{==} \PY{n}{couple4}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}2}]:} True
\end{Verbatim}
            
    Comme on le voit~:
    
\begin{itemize}
	\item 
	en réalité la \textbf{parenthèse est parfois
	superflue}~; mais il se trouve qu'elle est \textbf{largement utilisée}
	pour améliorer la lisibilité des programmes, sauf dans le cas du
	\emph{tuple unpacking}~; nous verrons aussi plus bas qu'elle est
	\textbf{parfois nécessaire} selon l'endroit où le tuple apparaît dans le
	programme~;
	\item
	la \textbf{dernière virgule est optionnelle} aussi, c'est
	le cas pour les tuples à au moins 2 éléments - nous verrons plus bas le
	cas des tuples à un seul élément.
\end{itemize}

    \hypertarget{conseil-pour-la-pruxe9sentation-sur-plusieurs-lignes}{%
\subsubsection{Conseil pour la présentation sur plusieurs
lignes}\label{conseil-pour-la-pruxe9sentation-sur-plusieurs-lignes}}

    En général d'ailleurs, la forme avec parenthèses et virgule terminale
est plus pratique. Considérez par exemple l'initialisation suivante~; on
veut créer un tuple qui contient des listes (naturellement un tuple peut
contenir n'importe quel objet Python), et comme c'est assez long on
préfère mettre un élément du tuple par ligne~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{mon\PYZus{}tuple} \PY{o}{=} \PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}
                     \PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{5}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,}
                     \PY{p}{[}\PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{]}\PY{p}{,}
                    \PY{p}{)}
\end{Verbatim}


    L'avantage lorsqu'on choisit cette forme (avec parenthèses, et avec
virgule terminale), c'est d'abord qu'il n'est pas nécessaire de mettre
un backslash à la fin de chaque ligne~; parce que l'on est à l'intérieur
d'une zone parenthésée, l'interpréteur Python ``sait'' que l'instruction
n'est pas terminée et va se continuer sur la ligne suivante.\\

Deuxièmement, si on doit ultérieurement ajouter ou enlever un élément
dans le tuple, il suffira d'enlever ou d'ajouter toute une ligne, sans
avoir à s'occuper des virgules~; si on avait choisi de ne pas faire
figurer la virgule terminale, alors pour ajouter un élément dans le
tuple après le dernier, il ne faut pas oublier d'ajouter une virgule à
la ligne précédente. Cette simplicité se répercute au niveau du
gestionnaire de code source, où les différences dans le code sont plus
faciles à visualiser.\\

Signalons enfin que ceci n'est pas propre aux tuples. La virgule
terminale est également optionnelle pour les listes, ainsi d'ailleurs
que pour tous les types Python où cela fait du sens, comme les
dictionnaires et les ensembles que nous verrons bientôt. Et dans tous
les cas où on opte pour une présentation multi-lignes, il est conseillé
de faire figurer une virgule terminale.

    \hypertarget{tuples-uxe0-un-uxe9luxe9ment}{%
\subsubsection{Tuples à un élément}\label{tuples-uxe0-un-uxe9luxe9ment}}

    Pour revenir à présent sur le cas des tuples à un seul élément, c'est un
cas particulier, parmi les quatre syntaxes que l'on a vues ci-dessus, on
obtiendrait dans ce cas~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{c+c1}{\PYZsh{} ATTENTION : ces deux premières formes ne construisent pas un tuple !}
        \PY{n}{simple1} \PY{o}{=} \PY{l+m+mi}{1}
        \PY{n}{simple2} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{c+c1}{\PYZsh{} celles\PYZhy{}ci par contre construisent bien un tuple}
        \PY{n}{simple3} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{,}
        \PY{n}{simple4} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{p}{)}
\end{Verbatim}


    \begin{itemize}
\tightlist
\item
  Il est bien évident que la première forme ne crée pas de tuple~;
\item
  et en fait la seconde non plus, car Python lit ceci comme une
  expression parenthésée, avec seulement un entier.
\end{itemize}

Et en fait ces deux premières formes créent un entier simple~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n+nb}{type}\PY{p}{(}\PY{n}{simple2}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}5}]:} int
\end{Verbatim}
            
    Les deux autres formes créent par contre toutes les deux un tuple à un
élément comme on cherchait à le faire~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n+nb}{type}\PY{p}{(}\PY{n}{simple3}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}6}]:} tuple
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{n}{simple3} \PY{o}{==} \PY{n}{simple4}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}7}]:} True
\end{Verbatim}
            
    Pour conclure, disons donc qu'il est conseillé de \textbf{toujours
mentionner une virgule terminale} lorsqu'on construit des tuples.

    \hypertarget{parenthuxe8se-parfois-obligatoire}{%
\subsubsection{Parenthèse parfois
obligatoire}\label{parenthuxe8se-parfois-obligatoire}}

    Dans certains cas vous vous apercevrez que la parenthèse est
obligatoire. Par exemple on peut écrire~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n}{x} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{p}{)}
        \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{p}{)} \PY{o}{==} \PY{n}{x}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}8}]:} True
\end{Verbatim}
            
    Mais si on essaie d'écrire le même test sans les parenthèses~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{c+c1}{\PYZsh{} ceci provoque une SyntaxError}
        \PY{l+m+mi}{1}\PY{p}{,} \PY{o}{==} \PY{n}{x}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

          File "<ipython-input-9-219921aa55c4>", line 2
        1, == x
            \^{}
    SyntaxError: invalid syntax
    

    \end{Verbatim}

    Python lève une erreur de syntaxe~; encore une bonne raison pour
utiliser les parenthèses.

    \hypertarget{addition-de-tuples}{%
\subsubsection{Addition de tuples}\label{addition-de-tuples}}

    Bien que le type tuple soit immuable, il est tout à fait légal
d'additionner deux tuples, et l'addition va produire un \textbf{nouveau}
tuple~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n}{tuple1} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,}\PY{p}{)}
         \PY{n}{tuple2} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{addition}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{tuple1} \PY{o}{+} \PY{n}{tuple2}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
addition (1, 2, 3, 4)

    \end{Verbatim}

    Ainsi on peut également utiliser l'opérateur \texttt{+=} avec un tuple
qui va créer, comme précédemment, un nouvel objet tuple~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{tuple1} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,}\PY{p}{)}
         \PY{n}{tuple1} \PY{o}{+}\PY{o}{=} \PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{apres ajout}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{tuple1}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
apres ajout (1, 2, 3, 4)

    \end{Verbatim}

    \hypertarget{construire-des-tuples-uxe9laboruxe9s}{%
\subsubsection{Construire des tuples
élaborés}\label{construire-des-tuples-uxe9laboruxe9s}}

    Malgré la possibilité de procéder par additions successives, la
construction d'un tuple peut s'avérer fastidieuse.\\

    Une astuce utile consiste à penser aux fonctions de conversion, pour
construire un tuple à partir de - par exemple - une liste. Ainsi on peut
faire par exemple ceci~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{c+c1}{\PYZsh{} on fabrique une liste pas à pas}
         \PY{n}{liste} \PY{o}{=} \PY{n+nb}{list}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{)}
         \PY{n}{liste}\PY{p}{[}\PY{l+m+mi}{9}\PY{p}{]} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Inconnu}\PY{l+s+s1}{\PYZsq{}}
         \PY{k}{del} \PY{n}{liste} \PY{p}{[}\PY{l+m+mi}{2}\PY{p}{:}\PY{l+m+mi}{5}\PY{p}{]}
         \PY{n}{liste}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}12}]:} [0, 1, 5, 6, 7, 8, 'Inconnu']
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{c+c1}{\PYZsh{} on convertit le résultat en tuple}
         \PY{n}{mon\PYZus{}tuple} \PY{o}{=} \PY{n+nb}{tuple}\PY{p}{(}\PY{n}{liste}\PY{p}{)}
         \PY{n}{mon\PYZus{}tuple}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}13}]:} (0, 1, 5, 6, 7, 8, 'Inconnu')
\end{Verbatim}
            
    \hypertarget{digression-sur-les-noms-de-fonctions-pruxe9duxe9finies}{%
\subsubsection{Digression sur les noms de fonctions
prédéfinies}\label{digression-sur-les-noms-de-fonctions-pruxe9duxe9finies}}

    \textbf{Remarque}~: Vous avez peut-être observé que nous avons choisi de
ne pas appeler notre tuple simplement \texttt{tuple}. C'est une bonne
pratique en général d'éviter les noms de fonctions prédéfinies par
Python.\\

Ces variables en effet sont des variables ``comme les autres''. Imaginez
qu'on ait en fait deux tuples à construire comme ci-dessus, voici ce
qu'on obtiendrait si on n'avait pas pris cette précaution~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n}{liste} \PY{o}{=} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} ATTENTION : ceci redéfinit le symbole tuple}
         \PY{n+nb}{tuple} \PY{o}{=} \PY{n+nb}{tuple}\PY{p}{(}\PY{n}{liste}\PY{p}{)}
         \PY{n+nb}{tuple}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}14}]:} (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{c+c1}{\PYZsh{} si bien que maintenant on ne peut plus faire ceci}
         \PY{c+c1}{\PYZsh{} car à ce point, tuple ne désigne plus le type tuple}
         \PY{c+c1}{\PYZsh{} mais l\PYZsq{}objet qu\PYZsq{}on vient de créer}
         \PY{n}{autre\PYZus{}liste} \PY{o}{=} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{100}\PY{p}{)}
         \PY{n}{autre\PYZus{}tuple} \PY{o}{=} \PY{n+nb}{tuple}\PY{p}{(}\PY{n}{autre\PYZus{}liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        ---------------------------------------------------------------------------

        TypeError                                 Traceback (most recent call last)

        <ipython-input-15-15ef2d1e6804> in <module>()
          3 \# mais l'objet qu'on vient de créer
          4 autre\_liste = range(100)
    ----> 5 autre\_tuple = tuple(autre\_liste)
    

        TypeError: 'tuple' object is not callable

    \end{Verbatim}

    Il y a une erreur parce que nous avons remplacé (ligne 2) la valeur de
la variable \texttt{tuple}, qui au départ référençait le \textbf{type}
tuple (ou si on préfère la fonction de conversion), par un
\textbf{objet} tuple. Ainsi en ligne 5, lorsqu'on appelle à nouveau
\texttt{tuple}, on essaie d'exécuter un objet qui n'est pas `appelable'
(\emph{not callable} en anglais).\\

D'un autre côté, l'erreur est relativement facile à trouver dans ce cas.
En cherchant toutes les occurrences de \texttt{tuple} dans notre propre
code on voit assez vite le problème. De plus, je vous rappelle que votre
éditeur de texte \textbf{doit} faire de la coloration syntaxique, et que
toutes les fonctions built-in (dont \texttt{tuple} et \texttt{list} font
partie) sont colorées spécifiquement (par exemple, en violet sous IDLE).
En pratique, avec un bon éditeur de texte et un peu d'expérience, cette
erreur est très rare.