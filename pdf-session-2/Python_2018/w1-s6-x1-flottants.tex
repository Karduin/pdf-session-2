    \hypertarget{estimer-le-plus-petit-grand-flottant}{%
\section{Estimer le plus petit (grand)
flottant}\label{estimer-le-plus-petit-grand-flottant}}

    \hypertarget{exercice---niveau-basique}{%
\subsection{Exercice - niveau basique}\label{exercice---niveau-basique}}

    \hypertarget{le-plus-petit-flottant}{%
\subsubsection{Le plus petit flottant}\label{le-plus-petit-flottant}}

    En corollaire de la discussion sur la précision des flottants, il faut
savoir que le système de codage en mémoire impose aussi une limite. Les
réels très petits, ou très grands, ne peuvent plus être représentés de
cette manière.\\

C'est notamment très gênant si vous implémentez un logiciel
probabiliste, comme des graphes de Markov, où les probabilités
d'occurrence de séquences très longues tendent très rapidement vers des
valeurs extrêmement petites.\\

    Le but de cet exercice est d'estimer la valeur du plus petit flottant
qui peut être représenté comme un flottant. Pour vous aider, voici deux
valeurs~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{o}{\PYZhy{}}\PY{l+m+mi}{320}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}1}]:} 1e-320
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{o}{\PYZhy{}}\PY{l+m+mi}{330}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}2}]:} 0.0
\end{Verbatim}
            
    Comme on le voit, \(10^{-320}\) est correctement imprimé, alors que
\(10^{-330}\) est, de manière erronée, rapporté comme étant nul.\\

    \textbf{Notes~:}

\begin{itemize}
\item
  À ce stade du cours, pour estimer le plus petit flottant, procédez
  simplement par approximations successives.
\item
  Sans utiliser de boucle, la précision que vous pourrez obtenir n'est
  que fonction de votre patience, ne dépassez pas 4 à 5 itérations
  successives :)
\item
  Il est par contre pertinent d'utiliser une approche rationnelle pour
  déterminer l'itération suivante (par opposition à une approche ``au
  petit bonheur''). Pour ceux qui ne connaissent pas, nous vous
  recommandons de vous documenter sur l'algorithme de
  \href{https://fr.wikipedia.org/wiki/Recherche_dichotomique}{\textbf{dichotomie}}.
\end{itemize}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{o}{\PYZhy{}}\PY{l+m+mi}{325}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}3}]:} 0.0
\end{Verbatim}
            
    Voici quelques cellules de code vides~; vous pouvez en créer d'autres si
nécessaire, le plus simple étant de taper \texttt{Alt+Enter}, ou
d'utiliser le menu \emph{``Insert~-\textgreater{}~Insert~Cell~Below''}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} vos essais successifs ici}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{o}{.}\PY{l+m+mi}{24}\PY{o}{*}\PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{o}{\PYZhy{}}\PY{l+m+mi}{323}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}4}]:} 0.0
\end{Verbatim}
            
    \hypertarget{le-plus-grand-flottant}{%
\subsubsection{Le plus grand flottant}\label{le-plus-grand-flottant}}

    La même limitation s'applique sur les grands nombres. Toutefois, cela
est un peu moins évident, car comme toujours il faut faire attention aux
types~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{450}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}4}]:} 100000000000000000000000000000000000000000000000000000000000000000000000\\
        000000000000000000000000000000000000000000000000000000000000000000000000\\
        000000000000000000000000000000000000000000000000000000000000000000000000\\
        000000000000000000000000000000000000000000000000000000000000000000000000\\
        000000000000000000000000000000000000000000000000000000000000000000000000\\
        000000000000000000000000000000000000000000000000000000000000000000000000\\
        0000000000000000000
\end{Verbatim}
            
    Ce qui passe très bien car j'ai utilisé un \texttt{int} pour l'exposant.
Dans ce premier cas Python calcule le résultat comme un \texttt{int},
qui est un type qui n'a pas de limitation de précision (Python utilise
intelligemment autant de bits que nécessaire pour ce genre de calculs).\\

Par contre, si j'essaie de faire le même calcul avec un exposant
flottant, Python essaie cette fois de faire son calcul avec un flottant,
et là on obtient une erreur~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{450.0}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        ---------------------------------------------------------------------------

        OverflowError                             Traceback (most recent call last)

        <ipython-input-6-d63f7e475389> in <module>()
    ----> 1 10**450.0
    

        OverflowError: (34, 'Result too large')

    \end{Verbatim}

    On peut d'ailleurs remarquer que le comportement ici n'est pas
extrêmement cohérent, car avec les petits nombres Python nous a
silencieusement transformé \(10^{-330}\) en \(0\), alors que pour les
grands nombres, il lève une exception (nous verrons les exceptions plus
tard, mais vous pouvez dès maintenant remarquer que le comportement est
différent dans les deux cas).\\

    Quoi qu'il en soit, la limite pour les grands nombres se situe entre les
deux valeurs \(10^{300}\) et \(10^{310}\). On vous demande à nouveau
d'estimer comme ci-dessus une valeur approchée du plus grand nombre
qu'il soit possible de représenter comme un flottant.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{300.}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}7}]:} 1e+300
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{l+m+mf}{310.}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]

        ---------------------------------------------------------------------------

        OverflowError                             Traceback (most recent call last)

        <ipython-input-8-5d701e1fa38c> in <module>()
    ----> 1 10**310.
    

        OverflowError: (34, 'Result too large')

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} vos essais successifs ici}
\end{Verbatim}


    \hypertarget{compluxe9ment---niveau-avancuxe9}{%
\subsection{Complément - niveau
avancé}\label{compluxe9ment---niveau-avancuxe9}}

    En fait, on peut accéder à ces valeurs minimales et maximales pour les
flottants comme ceci

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{k+kn}{import} \PY{n+nn}{sys}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{sys}\PY{o}{.}\PY{n}{float\PYZus{}info}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
sys.float\_info(max=1.7976931348623157e+308, max\_exp=1024, max\_10\_exp=308,
min=2.2250738585072014e-308, min\_exp=-1021, min\_10\_exp=-307, dig=15,
mant\_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)

    \end{Verbatim}

    Et notamment,
\href{https://docs.python.org/3/library/sys.html\#sys.float_info}{comme
expliqué ici}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Flottant minimum}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{sys}\PY{o}{.}\PY{n}{float\PYZus{}info}\PY{o}{.}\PY{n}{min}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Flottant maximum}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{sys}\PY{o}{.}\PY{n}{float\PYZus{}info}\PY{o}{.}\PY{n}{max}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Flottant minimum 2.2250738585072014e-308
Flottant maximum 1.7976931348623157e+308

    \end{Verbatim}

    \textbf{Sauf que} vous devez avoir trouvé un maximum voisin de cette
valeur, mais le minimum observé expérimentalement ne correspond pas bien
à cette valeur.\\

Pour ceux que cela intéresse, l'explication à cette apparente
contradiction réside dans l'utilisation de
\href{http://en.wikipedia.org/wiki/Denormal\%5Fnumber}{nombres
dénormaux}.