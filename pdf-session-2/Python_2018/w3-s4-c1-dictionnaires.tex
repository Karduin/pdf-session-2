    \hypertarget{dictionnaires}{%
\section{Dictionnaires}\label{dictionnaires}}

    \hypertarget{compluxe9ment---niveau-basique}{%
\subsection{Complément - niveau
basique}\label{compluxe9ment---niveau-basique}}

    Ce document résume les opérations courantes disponibles sur le type
\texttt{dict}. On rappelle que le type \texttt{dict} est un type
\textbf{mutable}.

    \hypertarget{cruxe9ation-en-extension}{%
\subsubsection{Création en extension}\label{cruxe9ation-en-extension}}

    On l'a vu, la méthode la plus directe pour créer un dictionnaire est en
extension comme ceci~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{n}{annuaire} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{marc}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{35}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{30}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{eric}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+m+mi}{38}\PY{p}{\PYZcb{}}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{annuaire}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
\{'marc': 35, 'alice': 30, 'eric': 38\}

    \end{Verbatim}

    \hypertarget{cruxe9ation---la-fonction-dict}{%
\subsubsection{Création - la fonction
dict}\label{cruxe9ation---la-fonction-dict}}

    Comme pour les fonctions \texttt{int} ou \texttt{list}, la fonction
\texttt{dict} est une fonction de construction de dictionnaire - on dit
un constructeur. On a vu aussi dans la vidéo qu'on peut utiliser ce
constructeur à base d'une liste de tuples (\texttt{clé},
\texttt{valeur})

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{c+c1}{\PYZsh{} le paramètre de la fonction dict est}
        \PY{c+c1}{\PYZsh{} une liste de couples (clé, valeur)}
        \PY{n}{annuaire} \PY{o}{=} \PY{n+nb}{dict}\PY{p}{(}\PY{p}{[}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{marc}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{35}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{alice}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{30}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{eric}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{38}\PY{p}{)}\PY{p}{]}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{annuaire}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
\{'marc': 35, 'alice': 30, 'eric': 38\}

    \end{Verbatim}

    Remarquons qu'on peut aussi utiliser cette autre forme d'appel à
\texttt{dict} pour un résultat équivalent~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{annuaire} \PY{o}{=} \PY{n+nb}{dict}\PY{p}{(}\PY{n}{marc}\PY{o}{=}\PY{l+m+mi}{35}\PY{p}{,} \PY{n}{alice}\PY{o}{=}\PY{l+m+mi}{30}\PY{p}{,} \PY{n}{eric}\PY{o}{=}\PY{l+m+mi}{38}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{annuaire}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
\{'marc': 35, 'alice': 30, 'eric': 38\}

    \end{Verbatim}

    Remarquez ci-dessus l'absence de quotes autour des clés comme
\texttt{marc}. Il s'agit d'un cas particulier de passage d'arguments que
nous expliciterons plus longuement en fin de semaine 4.

    \hypertarget{accuxe8s-atomique}{%
\subsubsection{Accès atomique}\label{accuxe8s-atomique}}

    Pour accéder à la valeur associée à une clé, on utilise la notation à
base de crochets \texttt{{[}{]}}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{la valeur pour marc est}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{annuaire}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{marc}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
la valeur pour marc est 35

    \end{Verbatim}

    Cette forme d'accès ne fonctionne que si la clé est effectivement
présente dans le dictionnaire. Dans le cas contraire, une exception
\texttt{KeyError} est levée. Aussi si vous n'êtes pas sûr que la clé
soit présente, vous pouvez utiliser la méthode \texttt{get} qui accepte
une valeur par défaut~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{valeur pour marc}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{annuaire}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{marc}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{valeur pour inconnu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{annuaire}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{inconnu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
valeur pour marc 35
valeur pour inconnu 0

    \end{Verbatim}

    Le dictionnaire est un type \textbf{mutable}, et donc on peut
\textbf{modifier la valeur} associée à une clé~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n}{annuaire}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{eric}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{39}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{annuaire}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
\{'marc': 35, 'alice': 30, 'eric': 39\}

    \end{Verbatim}

    Ou encore, exactement de la même façon, \textbf{ajouter une entrée}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{n}{annuaire}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{bob}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{42}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{annuaire}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
\{'marc': 35, 'alice': 30, 'eric': 39, 'bob': 42\}

    \end{Verbatim}

    Enfin pour \textbf{détruire une entrée}, on peut utiliser l'instruction
\texttt{del} comme ceci~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{c+c1}{\PYZsh{} pour supprimer la clé \PYZsq{}marc\PYZsq{} et donc sa valeur aussi}
        \PY{k}{del} \PY{n}{annuaire}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{marc}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{annuaire}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
\{'alice': 30, 'eric': 39, 'bob': 42\}

    \end{Verbatim}

    Pour savoir si une clé est présente ou non, il est conseillé d'utiliser
l'opérateur d'appartenance \texttt{in} comme ceci~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{c+c1}{\PYZsh{} forme recommandée}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{john}\PY{l+s+s1}{\PYZsq{}} \PY{o+ow}{in} \PY{n}{annuaire}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
False

    \end{Verbatim}

    \hypertarget{parcourir-toutes-les-entruxe9es}{%
\subsubsection{Parcourir toutes les
entrées}\label{parcourir-toutes-les-entruxe9es}}

    La méthode la plus fréquente pour parcourir tout un dictionnaire est à
base de la méthode \texttt{items}~; voici par exemple comment on
pourrait afficher le contenu~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{k}{for} \PY{n}{nom}\PY{p}{,} \PY{n}{age} \PY{o+ow}{in} \PY{n}{annuaire}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZob{}nom\PYZcb{}}\PY{l+s+s2}{, age }\PY{l+s+si}{\PYZob{}age\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
alice, age 30
eric, age 39
bob, age 42

    \end{Verbatim}

    On remarque d'abord que les entrées sont listées dans le désordre, plus
précisément, il n'y a pas de notion d'ordre dans un dictionnaire~; ceci
est dû à l'action de la fonction de hachage, que nous avons vue dans la
vidéo précédente.\\

    On peut obtenir séparément la liste des clés et des valeurs avec~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{k}{for} \PY{n}{clé} \PY{o+ow}{in} \PY{n}{annuaire}\PY{o}{.}\PY{n}{keys}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{clé}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
alice
eric
bob

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{k}{for} \PY{n}{valeur} \PY{o+ow}{in} \PY{n}{annuaire}\PY{o}{.}\PY{n}{values}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{valeur}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
30
39
42

    \end{Verbatim}

    \hypertarget{la-fonction-len}{%
\subsubsection{\texorpdfstring{La fonction
\texttt{len}}{La fonction len}}\label{la-fonction-len}}

    On peut comme d'habitude obtenir la taille d'un dictionnaire avec la
fonction \texttt{len}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{len(annuaire)\PYZcb{} entrées dans annuaire}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
3 entrées dans annuaire

    \end{Verbatim}

    \hypertarget{pour-en-savoir-plus-sur-le-type-dict}{%
\subsubsection{\texorpdfstring{Pour en savoir plus sur le type
\texttt{dict}}{Pour en savoir plus sur le type dict}}\label{pour-en-savoir-plus-sur-le-type-dict}}

    Pour une liste exhaustive reportez-vous à la page de la documentation
Python ici~:\\

\href{https://docs.python.org/3/library/stdtypes.html\#mapping-types-dict}{https://docs.python.org/3/library/stdtypes.html\#mapping-types-dict}

\newpage

    \hypertarget{compluxe9ment---niveau-intermuxe9diaire}{%
\subsection{Complément - niveau
intermédiaire}\label{compluxe9ment---niveau-intermuxe9diaire}}

    \hypertarget{la-muxe9thode-update}{%
\subsubsection{\texorpdfstring{La méthode
\texttt{update}}{La méthode update}}\label{la-muxe9thode-update}}

    On peut également modifier un dictionnaire avec le contenu d'un autre
dictionnaire avec la méthode \texttt{update}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{avant: }\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{list(annuaire.items())\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
avant: [('alice', 30), ('eric', 39), ('bob', 42)]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n}{annuaire}\PY{o}{.}\PY{n}{update}\PY{p}{(}\PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{jean}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{l+m+mi}{25}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{eric}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}\PY{l+m+mi}{70}\PY{p}{\PYZcb{}}\PY{p}{)}
         \PY{n+nb}{list}\PY{p}{(}\PY{n}{annuaire}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}15}]:} [('alice', 30), ('eric', 70), ('bob', 42), ('jean', 25)]
\end{Verbatim}
            
    \hypertarget{collections.ordereddict-dictionnaire-et-ordre-dinsertion}{%
\subsubsection{\texorpdfstring{\texttt{collections.OrderedDict}~:
dictionnaire et ordre
d'insertion}{collections.OrderedDict~: dictionnaire et ordre d'insertion}}\label{collections.ordereddict-dictionnaire-et-ordre-dinsertion}}

    \textbf{Attention}~: un dictionnaire est \textbf{non ordonné~!} Il ne se
souvient pas de l'ordre dans lequel les éléments ont été insérés.
C'était particulièrement visible dans les versions de Python jusque
3.5~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{python2}
        
        \PYZsh{} cette cellule utilise python\PYZhy{}2.7 pour illustrer le fait
        \PYZsh{} que les dictionnaires ne sont pas ordonnés
        
        d = \PYZob{}\PYZsq{}c\PYZsq{} : 3, \PYZsq{}b\PYZsq{} : 1, \PYZsq{}a\PYZsq{} : 2\PYZcb{}
        for k, v in d.items():
            print k, v
\end{Verbatim}


    En réalité, et depuis la version 3.6 de Python, il se trouve
qu'\textbf{incidemment} l'implémentation CPython (la plus répandue donc)
a été modifiée, et maintenant on peut avoir l'\textbf{impression} que
les dictionnaires sont ordonnés~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n}{d} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}} \PY{p}{:} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}} \PY{p}{:} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}} \PY{p}{:} \PY{l+m+mi}{2}\PY{p}{\PYZcb{}}
         \PY{k}{for} \PY{n}{k}\PY{p}{,} \PY{n}{v} \PY{o+ow}{in} \PY{n}{d}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{k}\PY{p}{,} \PY{n}{v}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
c 3
b 1
a 2

    \end{Verbatim}

    Il faut insister sur le fait qu'il s'agit d'un \textbf{détail
d'implémentation}, et que vous ne devez pas écrire du code qui suppose
que les dictionnaires sont ordonnés.\\

    Si vous avez besoin de dictionnaires qui sont \textbf{garantis}
ordonnés, voyez dans
\href{https://docs.python.org/3/library/collections.html}{le module
\texttt{collections}} la classe
\href{https://docs.python.org/3/library/collections.html\#collections.OrderedDict}{\texttt{OrderedDict}},
qui est une personnalisation (une sous-classe) du type \texttt{dict},
qui cette fois possède cette bonne propriété~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{k+kn}{from} \PY{n+nn}{collections} \PY{k}{import} \PY{n}{OrderedDict}
         \PY{n}{d} \PY{o}{=} \PY{n}{OrderedDict}\PY{p}{(}\PY{p}{)}
         \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{7}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{:}
             \PY{n}{d}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{=} \PY{n}{i}
         \PY{k}{for} \PY{n}{k}\PY{p}{,} \PY{n}{v} \PY{o+ow}{in} \PY{n}{d}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{OrderedDict}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{k}\PY{p}{,} \PY{n}{v}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
OrderedDict a a
OrderedDict 7 7
OrderedDict 3 3
OrderedDict x x

    \end{Verbatim}

    \hypertarget{collections.defaultdict-initialisation-automatique}{%
\subsubsection{\texorpdfstring{\texttt{collections.defaultdict}~:
initialisation
automatique}{collections.defaultdict~: initialisation automatique}}\label{collections.defaultdict-initialisation-automatique}}

    Imaginons que vous devez gérer un dictionnaire dont les valeurs sont des
listes, et que votre programme ajoute des valeurs au fur et à mesure
dans ces listes.\\

Avec un dictionnaire de base, cela peut vous amener à écrire un code qui
ressemble à ceci~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{c+c1}{\PYZsh{} imaginons qu\PYZsq{}on a lu dans un fichier des couples (x, y)}
         \PY{n}{tuples} \PY{o}{=} \PY{p}{[}
             \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,}
             \PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}
             \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}\PY{p}{,}
             \PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)}\PY{p}{,}
         \PY{p}{]}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{c+c1}{\PYZsh{} et on veut construire un dictionnaire}
         \PY{c+c1}{\PYZsh{} x \PYZhy{}\PYZgt{} [liste de tous les y connectés à x]}
         \PY{n}{resultat} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
         
         \PY{k}{for} \PY{n}{x}\PY{p}{,} \PY{n}{y} \PY{o+ow}{in} \PY{n}{tuples}\PY{p}{:}
             \PY{k}{if} \PY{n}{x} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{resultat}\PY{p}{:}
                 \PY{n}{resultat}\PY{p}{[}\PY{n}{x}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{p}{]}
             \PY{n}{resultat}\PY{p}{[}\PY{n}{x}\PY{p}{]}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{y}\PY{p}{)}
         
         \PY{k}{for} \PY{n}{key}\PY{p}{,} \PY{n}{value} \PY{o+ow}{in} \PY{n}{resultat}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
1 [2, 3]
2 [1, 4]

    \end{Verbatim}

    Cela fonctionne, mais n'est pas très élégant. Pour simplifier ce type de
traitement, vous pouvez utiliser \texttt{defaultdict}, une sous-classe
de \texttt{dict} dans le module \texttt{collections}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{k+kn}{from} \PY{n+nn}{collections} \PY{k}{import} \PY{n}{defaultdict}
         
         \PY{c+c1}{\PYZsh{} on indique que les valeurs doivent être créées à la volée}
         \PY{c+c1}{\PYZsh{} en utilisant la fonction list}
         \PY{n}{resultat} \PY{o}{=} \PY{n}{defaultdict}\PY{p}{(}\PY{n+nb}{list}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} du coup plus besoin de vérifier la présence de la clé}
         \PY{k}{for} \PY{n}{x}\PY{p}{,} \PY{n}{y} \PY{o+ow}{in} \PY{n}{tuples}\PY{p}{:}
             \PY{n}{resultat}\PY{p}{[}\PY{n}{x}\PY{p}{]}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{y}\PY{p}{)}
         
         \PY{k}{for} \PY{n}{key}\PY{p}{,} \PY{n}{value} \PY{o+ow}{in} \PY{n}{resultat}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
1 [2, 3]
2 [1, 4]

    \end{Verbatim}

    Cela fonctionne aussi avec le type \texttt{int}, lorsque vous voulez par
exemple compter des occurrences~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n}{compteurs} \PY{o}{=} \PY{n}{defaultdict}\PY{p}{(}\PY{n+nb}{int}\PY{p}{)}
         
         \PY{n}{phrase} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{une phrase dans laquelle on veut compter les caractères}\PY{l+s+s2}{\PYZdq{}}
         
         \PY{k}{for} \PY{n}{c} \PY{o+ow}{in} \PY{n}{phrase}\PY{p}{:}
             \PY{n}{compteurs}\PY{p}{[}\PY{n}{c}\PY{p}{]} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
         
         \PY{n+nb}{sorted}\PY{p}{(}\PY{n}{compteurs}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}22}]:} [(' ', 8),
          ('a', 5),
          ('c', 3),
          ('d', 1),
          ('e', 8),
          ('h', 1),
          ('l', 4),
          ('m', 1),
          ('n', 3),
          ('o', 2),
          ('p', 2),
          ('q', 1),
          ('r', 4),
          ('s', 4),
          ('t', 3),
          ('u', 3),
          ('v', 1),
          ('è', 1)]
\end{Verbatim}
            
    Signalons enfin une fonctionnalité un peu analogue, quoiqu'un peut moins
élégante à mon humble avis, mais qui est présente avec les dictionnaires
\texttt{dict} standard. Il s'agit de
\href{https://docs.python.org/3/library/stdtypes.html\#dict.setdefault}{la
méthode \texttt{setdefault}} qui permet, en un seul appel, de retourner
la valeur associée à une clé et de créer cette clé au besoin,
c'est-à-dire si elle n'est pas encore présente~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{c+c1}{\PYZsh{} avant}
         \PY{n}{annuaire}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}23}]:} \{'alice': 30, 'bob': 42, 'eric': 70, 'jean': 25\}
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{c+c1}{\PYZsh{} ceci sera sans effet car eric est déjà présent}
         \PY{n}{annuaire}\PY{o}{.}\PY{n}{setdefault}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{eric}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{50}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}24}]:} 70
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{c+c1}{\PYZsh{} par contre ceci va insérer une entrée dans le dictionnaire}
         \PY{n}{annuaire}\PY{o}{.}\PY{n}{setdefault}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{inconnu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+m+mi}{50}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}25}]:} 50
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{c+c1}{\PYZsh{} comme on le voit}
         \PY{n}{annuaire}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}26}]:} \{'alice': 30, 'bob': 42, 'eric': 70, 'inconnu': 50, 'jean': 25\}
\end{Verbatim}
            
    Notez bien que \texttt{setdefault} peut éventuellement créer une entrée
mais ne \textbf{modifie jamais} la valeur associée à une clé déjà
présente dans le dictionnaire, comme le nom le suggère d'ailleurs.

    \hypertarget{compluxe9ment---niveau-avancuxe9}{%
\subsection{Complément - niveau
avancé}\label{compluxe9ment---niveau-avancuxe9}}

    Pour bien appréhender les dictionnaires, il nous faut souligner
certaines particularités, à propos de la valeur de retour des méthodes
comme \texttt{items()}, \texttt{keys()} et \texttt{values()}.

    \hypertarget{ce-sont-des-objets-ituxe9rables}{%
\paragraph{Ce sont des objets
itérables\\\\}\label{ce-sont-des-objets-ituxe9rables}}

    Les méthodes \texttt{items()}, \texttt{keys()} et \texttt{values()} ne
retournent pas des listes (comme c'était le cas en Python 2), mais des
\textbf{objets itérables}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{n}{d} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}} \PY{p}{:} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}} \PY{p}{:} \PY{l+m+mi}{2}\PY{p}{\PYZcb{}}
         \PY{n}{keys} \PY{o}{=} \PY{n}{d}\PY{o}{.}\PY{n}{keys}\PY{p}{(}\PY{p}{)}
         \PY{n}{keys}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}27}]:} dict\_keys(['a', 'b'])
\end{Verbatim}
            
    Comme ce sont des itérables, on peut naturellement faire un \texttt{for}
avec, on l'a vu~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{k}{for} \PY{n}{key} \PY{o+ow}{in} \PY{n}{keys}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{key}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
a
b

    \end{Verbatim}

    Et un test d'appartenance avec \texttt{in}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}} \PY{o+ow}{in} \PY{n}{keys}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
True

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}} \PY{o+ow}{in} \PY{n}{keys}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
False

    \end{Verbatim}

    \hypertarget{mais-ce-ne-sont-pas-des-listes}{%
\paragraph{\texorpdfstring{Mais \textbf{ce ne sont pas des
listes}}{Mais ce ne sont pas des listes}}\label{mais-ce-ne-sont-pas-des-listes}}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}31}]:} \PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{keys}\PY{p}{,} \PY{n+nb}{list}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}31}]:} False
\end{Verbatim}
            
    Ce qui signifie qu'on n'a \textbf{pas alloué de mémoire} pour stocker
toutes les clés, mais seulement un objet qui ne prend pas de place, ni
de temps à construire~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}32}]:} \PY{c+c1}{\PYZsh{} construisons un dictionnaire}
         \PY{c+c1}{\PYZsh{} pour anticiper un peu sur la compréhension de dictionnaire}
         
         \PY{n}{big\PYZus{}dict} \PY{o}{=} \PY{p}{\PYZob{}}\PY{n}{k} \PY{p}{:} \PY{n}{k}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{n}{\PYZus{}000\PYZus{}000}\PY{p}{)}\PY{p}{\PYZcb{}}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}33}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit} \PYZhy{}n 10000
         \PYZsh{} créer un objet vue est très rapide
         big\PYZus{}keys = big\PYZus{}dict.keys()
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
193 ns ± 51 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{c+c1}{\PYZsh{} on répète ici car timeit travaille dans un espace qui lui est propre}
         \PY{c+c1}{\PYZsh{} et donc on n\PYZsq{}a pas défini big\PYZus{}keys pour notre interpréteur}
         \PY{n}{big\PYZus{}keys} \PY{o}{=} \PY{n}{big\PYZus{}dict}\PY{o}{.}\PY{n}{keys}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{timeit} \PYZhy{}n 20
         \PYZsh{} si on devait vraiment construire la liste ce serait beaucoup plus long
         big\PYZus{}lkeys = list(big\PYZus{}keys)
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
20.1 ms ± 391 µs per loop (mean ± std. dev. of 7 runs, 20 loops each)

    \end{Verbatim}

    \hypertarget{en-fait-ce-sont-des-vues}{%
\paragraph{\texorpdfstring{En fait ce sont des
\emph{vues}}{En fait ce sont des vues}}\label{en-fait-ce-sont-des-vues}}

    Une autre propriété un peu inattendue de ces objets, c'est que
\textbf{ce sont des vues}~; ce qu'on veut dire par là (pour ceux qui
connaissent, cela fait fait référence à la notion de vue dans les bases
de données) c'est que la vue \emph{voit} les changements fait sur
l'objet dictionnaire \emph{même après sa création}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} \PY{n}{d} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a}\PY{l+s+s1}{\PYZsq{}} \PY{p}{:} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}} \PY{p}{:} \PY{l+m+mi}{2}\PY{p}{\PYZcb{}}
         \PY{n}{keys} \PY{o}{=} \PY{n}{d}\PY{o}{.}\PY{n}{keys}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}37}]:} \PY{c+c1}{\PYZsh{} sans surprise, il y a deux clés dans keys}
         \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n}{keys}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{k}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
a
b

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}38}]:} \PY{c+c1}{\PYZsh{} mais si maintenant j\PYZsq{}ajoute un objet au dictionnaire}
         \PY{n}{d}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{3}
         \PY{c+c1}{\PYZsh{} alors on va \PYZsq{}voir\PYZsq{} cette nouvelle clé à partir}
         \PY{c+c1}{\PYZsh{} de l\PYZsq{}objet keys qui pourtant est inchangé}
         \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n}{keys}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{n}{k}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
a
b
c

    \end{Verbatim}

    Reportez vous à
\href{https://docs.python.org/3/library/stdtypes.html\#dictionary-view-objects}{la
section sur les vues de dictionnaires} pour plus de détails.

    \hypertarget{python-2}{%
\paragraph{Python 2}\label{python-2}}

    Ceci est naturellement en fort contraste avec tout ce qui se passait en
Python 2, où l'on avait des méthodes distinctes, par exemple
\texttt{keys()}, \texttt{iterkeys()} et \texttt{viewkeys()}, selon le
type d'objets que l'on souhaitait construire.